<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>6.0 Release Notes | Npgsql Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="6.0 Release Notes | Npgsql Documentation ">
  
    <link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
    <link rel="manifest" href="../../site.webmanifest">
    <link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/npgsql.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  <meta property="docfx:rel" content="../../">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="60-release-notes">6.0 Release Notes</h1>

<p>The release candidate of Npgsql Entity Framework Core provider version 6.0 has been released and is available on nuget. This version works with <a href="https://docs.microsoft.com/ef/core/what-is-new/ef-core-6.0/whatsnew">version 6.0 of Entity Framework Core</a>, and brings new Npgsql features in addition to the general EF Core changes.</p>
<p>Npgsql 6.0 brings some major breaking changes and is not a simple in-place upgrade. Carefully read the breaking change notes below and upgrade with care.</p>
<h2 id="new-features">New features</h2>
<h3 id="timestamp-rationalization-and-improvements">Timestamp rationalization and improvements</h3>
<p>Support for <code>timestamp with time zone</code> and <code>timestamp without time zone</code> has been rationalized and simplified, and aligned with PostgreSQL best practices. In particular, the &quot;UTC everywhere&quot; pattern is much better supported via the PostgreSQL <code>timestamp with time zone</code> type, which is the recommended way to handle timestamps. A detailed explanation is available in <a href="https://www.roji.org/postgresql-dotnet-timestamp-mapping">this blog post</a>, below is a summary of the main improvements.</p>
<ul>
<li>UTC timestamps have been cleanly separated from non-UTC timestamps, aligning with the PostgreSQL types. The former are represented by <code>timestamp with time zone</code> and DateTime with Kind UTC, the latter by <code>timestamp without time zone</code> and DateTime with Kind Local or Unspecified. It is recommended to use UTC timestamps where possible.</li>
<li>Npgsql no longer performs any implicit timezone conversions when reading or writing any timestamp value - the value in the database is what you get, and the machine timezone no longer plays any role when reading/writing values.</li>
<li>Npgsql no longer supports date/time representations which cannot be fully round-tripped to the database. If it can't be fully stored as-is, you can't write it.</li>
<li>A compatibility switch enables opting out of the new behavior, to maintain backwards compatibility.</li>
</ul>
<p>This change introduces significant breaking changes (see below), although a compatibility flag can be used to opt out and revert to the previous behavior.</p>
<p>Other date/time improvements include:</p>
<ul>
<li>Support for the new <a href="https://devblogs.microsoft.com/dotnet/date-time-and-time-zone-enhancements-in-net-6/">.NET DateOnly and TimeOnly types</a>.</li>
<li>Most <a href="https://docs.microsoft.com/dotnet/api/system.datetimeoffset">DateTimeOffset</a> members and methods are now translated.</li>
<li>Many NodaTime translations have been added for <a href="https://nodatime.org/3.0.x/api/NodaTime.ZonedDateTime.html">ZonedDateTime</a>, <a href="https://nodatime.org/3.0.x/api/NodaTime.Period.html">Period</a>, <a href="https://nodatime.org/3.0.x/api/NodaTime.DateInterval.html">DateInterval</a> and others.</li>
<li>PostgreSQL <code>tstzrange</code> is now mapped to NodaTime <a href="https://nodatime.org/3.0.x/api/NodaTime.Interval.html">Interval</a>, and PostgreSQL <code>daterange</code> is now mapped to NodaTime <a href="https://nodatime.org/3.0.x/api/NodaTime.DateInterval.html">DateInterval</a>. Most methods on these types are translated (<a href="https://github.com/npgsql/efcore.pg/issues/1998">#1998</a>, <a href="https://github.com/npgsql/efcore.pg/issues/2059">#2059</a>).</li>
</ul>
<h3 id="other-new-features">Other new features</h3>
<ul>
<li>The provider is now fully annotated for nullable reference types.</li>
<li>Full support for the PostgreSQL 14 <a href="https://www.postgresql.org/docs/14/rangetypes.html">multirange type</a>, mapped to arrays or lists of <code>NpgsqlRange&lt;T&gt;</code> (<a href="https://github.com/npgsql/efcore.pg/issues/1963">#1963</a>). Includes translation of all major operators and functions, <a href="../mapping/range.html">see the updated docs</a>.</li>
<li>Support for PostgreSQL 14 <a href="https://paquier.xyz/postgresql-2/postgres-14-table-compression/">column compression methods</a> (<a href="https://github.com/npgsql/efcore.pg/issues/2062">#2062</a>).</li>
<li>Support for the PostgreSQL <a href="https://www.postgresql.org/docs/current/ltree.html">ltree</a> type, which represents labels of data stored in a hierarchical tree-like structure. Requires PostgreSQL 13 and above.</li>
<li>Multiple spatial translations have been added for NetTopologySuite (<a href="https://github.com/npgsql/efcore.pg/issues/1827">DistanceKnn, &lt;-&gt;</a>, <a href="https://github.com/npgsql/efcore.pg/issues/1917">ST_Force2D</a>, <a href="https://github.com/npgsql/efcore.pg/issues/1638">ST_Distance and ST_DWithin with spheriod</a>).</li>
<li>More translations and better type inference for arrays (<a href="https://github.com/npgsql/efcore.pg/issues/2026">#2026</a>).</li>
</ul>
<p>The full list of issues for this release is <a href="https://github.com/npgsql/efcore.pg/milestone/34?closed=1">available here</a>.</p>
<h2 id="breaking-changes">Breaking changes</h2>
<h3 id="major-changes-to-timestamp-mapping">Major changes to timestamp mapping</h3>
<div class="NOTE">
<h5>Note</h5>
<p>It is possible to opt out of these changes to maintain backwards compatibility, see below.</p>
</div>
<h4 id="quick-summary">Quick summary</h4>
<ul>
<li>In many cases, it makes sense to store UTC timestamps in the database. To do this, migrate your <code>timestamp without time zone</code> columns to <code>timestamp with time zone</code> (<a href="#migrating-columns-from-timestamp-to-timestamptz">see migration notes below</a>), and always use either DateTime with Kind=Utc or DateTimeOffset with offset 0.
<ul>
<li>If using NodaTime (recommended), use either <a href="https://nodatime.org/3.0.x/api/NodaTime.Instant.html">Instant</a> or <a href="https://nodatime.org/3.0.x/api/NodaTime.ZonedDateTime.html">ZonedDateTime</a> with time zone UTC.</li>
</ul>
</li>
<li>To store non-UTC timestamps, use DateTime with Kind=Unspecified and <a href="https://docs.microsoft.com/ef/core/modeling/entity-properties#column-data-types">add explicit configuration</a> to your properties to be <code>timestamp without time zone</code>.
<ul>
<li>If using NodaTime (recommended), use <a href="https://nodatime.org/3.0.x/api/NodaTime.LocalDateTime.html">LocalDateTime</a> (no explicit column configuration is required).</li>
</ul>
</li>
</ul>
<h4 id="detailed-notes">Detailed notes</h4>
<p>The below notes will use the PostgreSQL aliases <code>timestamptz</code> to refer to <code>timestamp with time zone</code>, and <code>timestamp</code> to refer to <code>timestamp without time zone</code>. Note that <code>timestamp with time zone</code> represents a UTC timestamp and does <strong>not</strong> store a timezone in the database.</p>
<ul>
<li>DateTime properties now map to <code>timestamptz</code> by default, instead of to <code>timestamp</code>; this follows the recommended practice of storing UTC timestamps by default, but will cause the first migration to change your column type.
<ul>
<li>If the intention is to store point-in-time or UTC timestamps, it's recommended to allow the migration to occur (<a href="#migrating-columns-from-timestamp-to-timestamptz">see migration notes below</a>).</li>
<li>If the column really should store non-UTC timestamps (local or unspecified), <a href="https://docs.microsoft.com/ef/core/modeling/entity-properties#column-data-types">explicitly set the column type back to <code>timestamp</code></a>. This is usually discouraged, but can be a temporary solution before transitioning to <code>timestamptz</code>.</li>
</ul>
</li>
<li>It is no longer possible to write DateTime with Kinds Local or Unspecified to <code>timestamptz</code> properties (which are the default for DateTime). Previously, Npgsql allowed writing those, performing timezone conversions from local to UTC. To write to <code>timestamptz</code>, provide a UTC DateTime. Similarly, it is no longer possible to write DateTime with Kind UTC to a <code>timestamp</code> column.</li>
<li><code>timestamptz</code> values are now read back as DateTime with Kind=UTC, without any conversions; these were previously returned as local DateTime, converted to the local machine's timezone. When reading <code>timestamptz</code> values as <a href="https://docs.microsoft.com/dotnet/api/system.datetimeoffset">DateTimeOffset</a>, UTC values (offset 0) are always returned.</li>
<li>It is no longer possible to write <a href="https://docs.microsoft.com/dotnet/api/system.datetimeoffset">DateTimeOffset</a> with offsets other than 0 (UTC), since these cannot be represented in PostgreSQL. These were previously implicitly converted to UTC before sending.</li>
</ul>
<p>See the <a href="/doc/release-notes/5.0.html">Npgsql ADO.NET docs</a> for additional lower-level changes to timestamp handling.</p>
<h4 id="nodatime-changes">NodaTime changes</h4>
<ul>
<li>Properties with type <a href="https://nodatime.org/3.0.x/api/NodaTime.Instant.html">Instant</a> are now mapped to <code>timestamptz</code> columns, and not to <code>timestamp</code>, since they represent a universally agreed-upon point in time. This follows the recommended practice, but will cause the first migration to change your column type.
<ul>
<li>If the intention is to store point-in-time or UTC timestamps, it's recommended to allow the migration to occur (<a href="#migrating-columns-from-timestamp-to-timestamptz">see migration notes below</a>).</li>
<li>If the column really should store non-UTC timestamps (local or unspecified), change the property's type to <a href="https://nodatime.org/3.0.x/api/NodaTime.LocalDateTime.html">LocalDateTime</a> instead; this will maintain the mapping to <code>timestamp</code>. This is usually discouraged, but can be a temporary solution before transitioning to <code>timestamptz</code>.</li>
</ul>
</li>
<li>When reading <code>timestamptz</code> as <a href="https://nodatime.org/3.0.x/api/NodaTime.ZonedDateTime.html">ZonedDateTime</a> or <a href="https://nodatime.org/3.0.x/api/NodaTime.OffsetDateTime.html">OffsetDateTime</a>, UTC values are always returned. Previously, local values based on the PostgreSQL <code>TimeZone</code> parameter were returned.</li>
</ul>
<h4 id="migrating-columns-from-timestamp-to-timestamptz">Migrating columns from timestamp to timestamptz</h4>
<p>As a result of the above changes, the first migration created after upgrading to 6.0 will alter the columns for all DateTime and Instant properties from <code>timestamp</code> to <code>timestamptz</code>. If these columns are meant to store point-in-time or UTC timestamps (the recommended practice), then it's best to let this migration proceed; but care must be taken.</p>
<p>As a starting point, let's assume your existing <code>timestamp</code> column has the timestamp <code>2020-01-01 12:00:00</code>:</p>
<pre><code class="lang-sql">SELECT &quot;CreatedOn&quot;, pg_typeof(&quot;CreatedOn&quot;) AS type FROM &quot;Blogs&quot;;
</code></pre>
<p>Results in:</p>
<pre><code class="lang-output">      CreatedOn      |            type
---------------------+-----------------------------
 2020-01-01 12:00:00 | timestamp without time zone
</code></pre>
<p>The migration generated by version 6.0 will cause the following SQL to be generated:</p>
<pre><code class="lang-sql">ALTER TABLE &quot;Blogs&quot; ALTER COLUMN &quot;CreatedOn&quot; TYPE timestamp with time zone;
</code></pre>
<p>When converting the <code>timestamp without time zone</code> column to <code>timestamp with time zone</code>, PostgreSQL will assume that existing values are local timestamps, and will convert them to UTC based on the <code>TimeZone</code> parameter. Performing the above query will result in something like:</p>
<pre><code class="lang-output">        CreatedOn       |           type
------------------------+--------------------------
 2020-01-01 12:00:00+02 | timestamp with time zone
</code></pre>
<p>This means that your new <code>timestamptz</code> column now contains 10:00 UTC, which is probably not what you want: if the original values were in fact UTC values, you need them to be preserved as-is, changing only the column type. To do this, edit your migration and add the following to the top of your migration's Up and Down methods:</p>
<pre><code class="lang-c#">migrationBuilder.Sql(&quot;SET TimeZone='UTC';&quot;);
</code></pre>
<p>This will ensure that no time zone conversions will be applied when converting the columns:</p>
<pre><code class="lang-output">        CreatedOn       |           type
------------------------+--------------------------
 2020-01-01 14:00:00+02 | timestamp with time zone
</code></pre>
<h4 id="changing-timestamp-seed-data">Changing timestamp seed data</h4>
<p>When switching from <code>timestamp without time zone</code> to <code>timezone with time zone</code>, you may have have non-UTC timestamp literals in your seeding configuration:</p>
<pre><code class="lang-c#">modelBuilder.Entity&lt;Blog&gt;().HasData(new Blog { Id = 1, Timestamp = new DateTime(2020, 1, 1, 0, 0, 0) });
</code></pre>
<p>If so, you'll have to change these to be UTC. In addition, all migrations code since the change must be modified in the same way, to only seed UTC DateTime into the column; the model snapshot should be changed as well.</p>
<h4 id="opting-out-of-the-new-timestamp-mapping-logic">Opting out of the new timestamp mapping logic</h4>
<p>The changes described above are far-reaching, and may break applications in various ways. You can upgrade to version 6.0 but opt out of the new mapping by enabling the <code>Npgsql.EnableLegacyTimestampBehavior</code> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appcontext?view=net-5.0">AppContext switch</a>. To do this and revert to the legacy timestamp behavior, add the following to your context's constructor, before any Npgsql or EF Core operations are invoked:</p>
<pre><code class="lang-c#">AppContext.SetSwitch(&quot;Npgsql.EnableLegacyTimestampBehavior&quot;, true);
</code></pre>
<h3 id="nodatime-tstzrange-and-daterange-are-mapped-to-interval-and-dateinterval-by-default">NodaTime: tstzrange and daterange are mapped to Interval and DateInterval by default</h3>
<p>When using NodaTime, PostgreSQL <code>tstzrange</code> columns are scaffolded as <a href="https://nodatime.org/3.0.x/api/NodaTime.Interval.html">Interval</a> properties instead of <code>NpgsqlRange&lt;Instant&gt;</code> (<a href="https://github.com/npgsql/npgsql/issues/4070">#4070</a>), and <code>daterange</code> columns are scaffolded as <a href="https://nodatime.org/3.0.x/api/NodaTime.DateInterval.html">DateInterval</a> properties of <code>NpgsqlRange&lt;LocalDateTime&gt;</code> (<a href="https://github.com/npgsql/efcore.pg/issues/1998">#1998</a>).</p>
<h3 id="datetime-minmax-values-are-now-converted-to-postgresql-infinity-values-by-default">Date/time min/max values are now converted to PostgreSQL infinity values by default</h3>
<p>PostgreSQL has special <code>infinity</code> and <code>-infinity</code> values for timestamps and dates, which are later and earlier than other value. Npgsql has supported mapping <code>DateTime.MaxValue</code> and <code>MinValue</code> to these infinity values via an <code>Convert Infinity DateTime</code> connection string parameter, which was disabled by default. This behavior is now on by default, since <code>DateTime.MaxValue</code> and <code>MinValue</code> are very rarely used as actual timestamps/dates, and the <code>Convert Infinity DateTime</code> parameter has been removed. To disable infinity conversions, add the following at the start of your application:</p>
<pre><code class="lang-c#">AppContext.SetSwitch(&quot;Npgsql.DisableDateTimeInfinityConversions&quot;, true);
</code></pre>
<p><a href="/doc/types/datetime.html#infinity-values">See the date/time documentation</a> for more details.</p>
<h3 id="value-converters-for-arraylist-properties-need-to-use-a-special-new-api">Value converters for array/list properties need to use a special new API</h3>
<p>Previously, it was possible to configure value converters for array/list properties with the general EF Core API:</p>
<pre><code class="lang-c#">modelBuilder.Entity&lt;SomeEntity&gt;.Property(e =&gt; e.ValueConvertedArray)
    .HasConversion(w =&gt; w.Select(x =&gt; x.Value).ToArray(), v =&gt; v.Select(x =&gt; new IntWrapper(x)).ToArray());
</code></pre>
<p>This is no longer possible and will cause an exception to be thrown. Instead, use the new <code>HasPostgresArrayConversion</code> API, providing conversion lambdas for the array's <em>elements</em>:</p>
<pre><code class="lang-c#">modelBuilder.Entity&lt;SomeEntity&gt;.Property(e =&gt; e.ValueConvertedArray)
    .HasPostgresArrayConversion(w =&gt; w.Value, v =&gt; new IntWrapper(v));
</code></pre>
<h3 id="arrayslists-over-ranges-are-mapped-to-pg14-multiranges">Arrays/lists over ranges are mapped to PG14 multiranges</h3>
<p>PostgreSQL 14 introduced <a href="https://www.postgresql.org/docs/14/rangetypes.html">a new multirange type</a>, which is very similar to an array of ranges but supports various range-related operations efficiently. The provider now maps arrays and lists of <code>NpgsqlRange</code> to these new types by default. To map them to old-style arrays over ranges in PostgreSQL, <a href="https://docs.microsoft.com/ef/core/modeling/entity-properties#column-data-types">configure the column type explicitly</a>:</p>
<div class="tabGroup" id="tabgroup_bHGHmlrG6S">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S_annotations" role="tab" aria-controls="tabpanel_bHGHmlrG6S_annotations" data-tab="annotations" tabindex="0" aria-selected="true">Data Annotations</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S_fluent-api" role="tab" aria-controls="tabpanel_bHGHmlrG6S_fluent-api" data-tab="fluent-api" tabindex="-1">Fluent API</a>
</li>
</ul>
<section id="tabpanel_bHGHmlrG6S_annotations" role="tabpanel" data-tab="annotations">

<pre><code class="lang-c#">[Column(TypeName = &quot;int4range[]&quot;)]
public NpgsqlRange&lt;int&gt;[] SomeArrayOverIntNpgsqlRange { get; set;}
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S_fluent-api" role="tabpanel" data-tab="fluent-api" aria-hidden="true" hidden="hidden">

<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder
        .Entity&lt;Blog&gt;()
        .Property(e =&gt; e.SomeArrayOverIntNpgsqlRange)
        .HasColumnType(&quot;int4range[]&quot;);
}
</code></pre>
</section>
</div>
<h3 id="trigrams-and-fuzzystringmatch-plugins-are-now-built-in">Trigrams and FuzzyStringMatch plugins are now built-in</h3>
<p>The Npgsql.EntityFrameworkCore.PostgreSQL.Trigrams and Npgsql.EntityFrameworkCore.PostgreSQL.FuzzyStringMatch plugins have been integrated into the main provider; as a result, there are no 6.0 versions of these nuget packages - simply remove the package references from your project when upgrading to 6.0.0.</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/npgsql/doc/blob/main/conceptual/EFCore.PG/release-notes/6.0.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      © Copyright 2023 The Npgsql Development Team
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
