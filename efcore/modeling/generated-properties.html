<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Value Generation | Npgsql Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Value Generation | Npgsql Documentation ">
  
    <link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
    <link rel="manifest" href="../../site.webmanifest">
    <link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/npgsql.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  <meta property="docfx:rel" content="../../">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="value-generation">Value Generation</h1>

<div class="CAUTION"><h5>Caution</h5><p>In 3.0.0, the default value generation strategy has changed from the older SERIAL columns to the newer IDENTITY columns. Read the information below carefully if you are migrating an existing database.</p>
</div>
<div class="NOTE"><h5>Note</h5><p>It&#39;s recommended that you start by reading the general <a href="https://docs.microsoft.com/en-us/ef/core/modeling/generated-properties">Entity Framework Core docs on generated properties</a>.</p>
</div>
<h2 id="identity-and-serial-columns-auto-increment">Identity and serial columns (auto-increment)</h2>
<h3 id="introduction">Introduction</h3>
<p>Since PostgreSQL 10, the standard way to define auto-incrementing columns is &quot;identity columns&quot;. Prior to version 10, &quot;serial columns&quot; were used, which are less SQL-compliant and generally more difficult to manage. For more information on these, <a href="https://blog.2ndquadrant.com/postgresql-10-identity-columns/">see this blog post</a>. Note that since PostgreSQL 10, both support <code>smallint</code>, <code>integer</code> and <code>bigint</code> as their data type.</p>
<p>The Npgsql EF Core provider allows you to choose which of the above you want on a property-by-property basis, or globally on your model. The following &quot;value generation strategies&quot; are available:</p>
<ul>
<li><em>Identity by default</em>: an identity column whose values are <em>by default</em> generated at the database, but you can still override this behavior by providing values from your application. This will generate the clause <code>GENERATED BY DEFAULT AS IDENTITY</code> on your column, and is the default value generation strategy.</li>
<li><em>Identity always</em>: an identity column whose values are <em>always</em> generated at the database - you cannot provide values from your application. This will generate the clause <code>GENERATED ALWAYS AS IDENTITY</code> on your column.</li>
<li><em>Serial</em>: the traditional PostgreSQL serial column. This will create the column with the <code>serial</code> datatype. Recommended only if you are using an older PostgreSQL version.</li>
<li><em>Sequence HiLo</em>: See below</li>
</ul>
<p>Prior to version 3.0, the Npgsql provider generates &quot;serial&quot; columns for ID columns; starting with version 3.0, it generates &quot;identity by default&quot; instead. In other words, when <code>ValueGeneratedOnAdd</code> is specified on a <code>short</code>, <code>int</code> or <code>long</code> property, the Npgsql provider will automatically map it to a serial or identity column. Note that EF Core will automatically recognize key properties by convention (e.g. a property called <code>Id</code> in your entity) and will implicitly set them to <code>ValueGeneratedOnAdd</code>; a standard model with ID columns should automatically get created with the appropriate column type.</p>
<div class="CAUTION"><h5>Caution</h5><p>Since the default strategy has changed, if you have an existing database with migrations, the the first migration created after upgrading to version 3.0 will alter your tables and convert serial columns to identity ones. This is a sensitive, one-time migration operation that should be done with care, and carefully tested before deployment to production. Changing a value generation strategy is a significant change to an existing database.</p>
</div>
<h3 id="defining-the-default-strategy-for-the-entire-model">Defining the default strategy for the entire model</h3>
<p>You can easily control the value generation strategy for the entire model. For example, to opt out of the change to identity columns, simply place the following in your context&#39;s <code>OnModelCreating()</code>:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
    =&gt; modelBuilder.UseSerialColumns();
</code></pre><p>Note that if you are using PostgreSQL 9.6 or older, identity columns will not work. It is recommended to place the provider in compatibility mode with your specific version - this will also affect the default value generation strategy:</p>
<pre><code class="lang-c#">protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    =&gt; optionsBuilder.UseNpgsql(&quot;...&quot;, o =&gt; o.SetPostgresVersion(9, 6));
</code></pre><h3 id="defining-the-strategy-for-a-single-property">Defining the strategy for a single property</h3>
<p>Regardless of the model default, you can define a value-generation strategy on a property-by-property basis:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
    =&gt; modelBuilder.Entity&lt;Blog&gt;().Property(b =&gt; b.Id).UseIdentityAlwaysColumn();
</code></pre><h3 id="identity-sequence-options">Identity sequence options</h3>
<p>Identity columns have a standard sequence, managed behind the scenes by PostgreSQL; you can customize the sequence options for these. For example, the following makes the column values start at 100:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
    =&gt; modelBuilder.Entity&lt;Blog&gt;().Property(b =&gt; b.Id)
        .HasIdentityOptions(startValue: 100);
</code></pre><p>This can be especially useful when seeding data. Seeded data must explicitly specify all columns - including database-generated ones - but the backing sequence for identity columns isn&#39;t aware that the values are in use, and will generate conflicting values. This technique allows to start your identity sequence at a value higher than all seeded data values. Another strategy is to seed negative values only, allowing your identity column to start at 1.</p>
<p>It is not possible to specify sequence options for serial columns, but you can set up a sequence separately and configure the column&#39;s default value (see <a href="#standard-sequence-driven-columns">sequence-driven columns</a>).</p>
<h2 id="standard-sequence-driven-columns">Standard sequence-driven columns</h2>
<p>While identity and serial columns set up a sequence for you behind the scenes, sometimes you may want to manage sequence creation yourself. For example, you may want to have multiple columns drawing their default values from a single sequence. Adding a sequence to your model is described in <a href="https://docs.microsoft.com/ef/core/modeling/relational/sequences">the general EF Core documentation</a>; once the sequence is specified, you can simply set a column&#39;s default value to extract the next value from that sequence. Note that the SQL used to fetch the next value from a sequence differs across databases (see <a href="https://www.postgresql.org/docs/current/static/functions-sequence.html">the PostgreSQL docs</a>). Your models&#39; <code>OnModelCreating</code> should look like this:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.HasSequence&lt;int&gt;(&quot;OrderNumbers&quot;)
                .StartsAt(1000)
                .IncrementsBy(5);

    modelBuilder.Entity&lt;Order&gt;()
                .Property(o =&gt; o.OrderNo)
                .HasDefaultValueSql(&quot;nextval(&#39;\&quot;OrderNumbers\&quot;&#39;)&quot;);
}
</code></pre><h2 id="hilo-autoincrement-generation">HiLo Autoincrement Generation</h2>
<p>One disadvantage of database-generated values is that these values must be read back from the database after a row is inserted. If you&#39;re saving multiple related entities, this means you must perform multiple round-trips as the first entity&#39;s generated key must be read before writing the second one. One solution to this problem is HiLo value generation: rather than relying on the database to generate each and every value, the application &quot;allocates&quot; a range of values, which it can then populate directly on new entities without any additional round-trips. When the range is exhausted, a new range is allocated. In practical terms, this uses a sequence that increments by some large value (100 by default), allowing the application to insert 100 rows autonomously.</p>
<p>To use HiLo, specify <code>UseHiLo</code> on a property in your model&#39;s <code>OnModelCreating</code>:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
    =&gt; modelBuilder.Entity&lt;Blog&gt;()
                   .Property(b =&gt; b.Id)
                   .UseHiLo();
</code></pre><p>You can also make your model use HiLo everywhere:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
    =&gt; modelBuilder.UseHiLo();
</code></pre><h2 id="guiduuid-generation">GUID/UUID Generation</h2>
<p>By default, for GUID key properties, a random GUID is generated client-side by the EF provider and sent to the database.</p>
<p>To generate GUID&#39;s client-side for non-key properties, configure them as follows:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder
        .Entity&lt;Blog&gt;()
        .Property(b =&gt; b.SomeGuidProperty)
        .HasValueGenerator&lt;GuidValueGenerator&gt;();
}
</code></pre><p>If you prefer to generate values in the database instead, you can do so by specifying <code>HasDefaultValueSql</code> on your property, and call the function to generate the value in the SQL expression. Which function to use depends on your PostgreSQL version:</p>
<div class="tabGroup" id="tabgroup_C1U9BHOkzs">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_C1U9BHOkzs_13" role="tab" aria-controls="tabpanel_C1U9BHOkzs_13" data-tab="13" tabindex="0" aria-selected="true">PG 13+</a>
</li>
<li role="presentation">
<a href="#tabpanel_C1U9BHOkzs_older" role="tab" aria-controls="tabpanel_C1U9BHOkzs_older" data-tab="older" tabindex="-1">Older</a>
</li>
</ul>
<section id="tabpanel_C1U9BHOkzs_13" role="tabpanel" data-tab="13">
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder
        .Entity&lt;Blog&gt;()
        .Property(e =&gt; e.SomeGuidProperty)
        .HasDefaultValueSql(&quot;gen_random_uuid()&quot;);
}
</code></pre></section>
<section id="tabpanel_C1U9BHOkzs_older" role="tabpanel" data-tab="older" aria-hidden="true" hidden="hidden">
<p>Versions of PostgreSQL prior to 13 don&#39;t include any GUID/UUID generation functions, but extensions such as <code>uuid-ossp</code> or <code>pgcrypto</code> exist to fill thie gap. This can be done by placing the following code in your model&#39;s <code>OnModelCreating</code>:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.HasPostgresExtension(&quot;uuid-ossp&quot;);    

    modelBuilder
        .Entity&lt;Blog&gt;()
        .Property(e =&gt; e.SomeGuidProperty)
        .HasDefaultValueSql(&quot;uuid_generate_v4()&quot;);
}
</code></pre></section>
</div>
<p>See <a href="https://www.postgresql.org/docs/current/static/datatype-uuid.html">the PostgreSQL docs on UUID for more details</a>.</p>
<div class="NOTE"><h5>Note</h5><p>Generating <code>Guid</code> values in the database causes an additional network roundtrip when a principal and a dependent are inserted in the same <code>SaveChanges</code>, as the principal&#39;s key needs to be fetched before inserting the dependent&#39;s.</p>
</div>
<h2 id="timestamp-generation">Timestamp generation</h2>
<p>In many scenarios, it&#39;s useful to have a column containing the timestamp when the row was originally created. To do this, add a <code>DateTime</code> property to your entity type (or <code>Instant</code> if using NodaTime) , and configure its default with <code>HasDefaultValueSql</code> as follows:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder
        .Entity&lt;Blog&gt;()
        .Property(e =&gt; e.SomeDateTimeProperty)
        .HasDefaultValueSql(&quot;now()&quot;);
}
</code></pre><p>In other scenarios, a &quot;last updated&quot; is needed, which is automatically updated every time is modified. Unfortunately, while PostgreSQL supports <a href="https://www.postgresql.org/docs/current/ddl-generated-columns.html">generated columns</a>, the use of functions such as <code>now()</code> isn&#39;t supported. It&#39;s still possible to use database trigger to set this up; triggers can be managed by <a href="https://docs.microsoft.com/ef/core/managing-schemas/migrations/managing#adding-raw-sql">adding raw SQL to your migrations</a>, as follows:</p>
<pre><code class="lang-sql">CREATE FUNCTION &quot;Blogs_Update_Timestamp_Function&quot;() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
    NEW.&quot;Timestamp&quot; := now();
    RETURN NEW;
END;
$$;

CREATE TRIGGER &quot;UpdateTimestamp&quot;
    BEFORE INSERT OR UPDATE
    ON &quot;Blogs&quot;
    FOR EACH ROW
    EXECUTE FUNCTION &quot;Blogs_Update_Timestamp_Function&quot;();
</code></pre><h2 id="computed-columns">Computed Columns</h2>
<div class="NOTE"><h5>Note</h5><p>This feature works only on PostgreSQL 12 or above, and was introduced in version 3.0.0 of the provider.</p>
</div>
<p>PostgreSQL 12 added support for <a href="https://www.postgresql.org/docs/current/ddl-generated-columns.html">stored generated columns</a>, and Npgsql feature supports that feature as well:</p>
<div class="tabGroup" id="tabgroup_C1U9BHOkzs-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_C1U9BHOkzs-1_efcore5" role="tab" aria-controls="tabpanel_C1U9BHOkzs-1_efcore5" data-tab="efcore5" tabindex="0" aria-selected="true">Version 5.0</a>
</li>
<li role="presentation">
<a href="#tabpanel_C1U9BHOkzs-1_efcore3" role="tab" aria-controls="tabpanel_C1U9BHOkzs-1_efcore3" data-tab="efcore3" tabindex="-1">Version 3.x</a>
</li>
</ul>
<section id="tabpanel_C1U9BHOkzs-1_efcore5" role="tabpanel" data-tab="efcore5">
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Person&gt;()
      .Property(p =&gt; p.DisplayName)
      .HasComputedColumnSql(@&quot;&quot;&quot;FirstName&quot;&quot; || &#39; &#39; || &quot;&quot;LastName&quot;&quot;&quot;, stored: true);
}
</code></pre></section>
<section id="tabpanel_C1U9BHOkzs-1_efcore3" role="tabpanel" data-tab="efcore3" aria-hidden="true" hidden="hidden">
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Person&gt;()
      .Property(p =&gt; p.DisplayName)
      .HasComputedColumnSql(@&quot;&quot;&quot;FirstName&quot;&quot; || &#39; &#39; || &quot;&quot;LastName&quot;&quot;&quot;);
}
</code></pre></section>
</div>
<p>This will cause the following migration SQL to be generated:</p>
<pre><code class="lang-sql">ALTER TABLE &quot;&quot;Person&quot;&quot; ADD &quot;&quot;DisplayName&quot;&quot; text GENERATED ALWAYS AS (&quot;&quot;FirstName&quot;&quot; || &#39; &#39; || &quot;&quot;LastName&quot;&quot;) STORED;
</code></pre><p>Note that this is a <em>stored</em> column - it is computed once when the row is updated, and takes space on disk. Virtual computed columns, which are computed on each select, are not yet supported by PostgreSQL.</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/npgsql/doc/blob/main/conceptual/EFCore.PG/modeling/generated-properties.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      © Copyright 2022 The Npgsql Development Team
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
