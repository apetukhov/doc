<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>PostgreSQL enums and composites | Npgsql Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="PostgreSQL enums and composites | Npgsql Documentation ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/types/enums_and_composites.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="postgresql-enums-and-composites">PostgreSQL enums and composites</h1>

<p>PostgreSQL supports <a href="http://www.postgresql.org/docs/current/static/datatype-enum.html">enum types</a> and <a href="http://www.postgresql.org/docs/current/static/rowtypes.html">composite types</a> as database columns, and Npgsql supports reading and writing these. This allows you to seamlessly read and write enum and composite values to the database without worrying about conversions.</p>
<h2 id="creating-your-types">Creating your types</h2>
<p>Let's assume you've created some enum and composite types in PostgreSQL:</p>
<pre><code class="lang-sql">CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);
</code></pre>
<p>To use these types with Npgsql, you must first define corresponding CLR types that will be mapped to the PostgreSQL types:</p>
<pre><code class="lang-csharp">public enum Mood
{
    Sad,
    Ok,
    Happy
}

public class InventoryItem
{
    public string Name { get; set; } = &quot;&quot;;
    public int SupplierId { get; set; }
    public decimal Price { get; set; }
}
</code></pre>
<h2 id="mapping-your-clr-types">Mapping your CLR types</h2>
<p>Once your types are defined both in PostgreSQL and in C#, you can now configure the mapping between them with Npgsql.</p>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_datasource" role="tab" aria-controls="tabpanel_1_datasource" data-tab="datasource" tabindex="0" aria-selected="true">NpgsqlDataSource</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_global" role="tab" aria-controls="tabpanel_1_global" data-tab="global" tabindex="-1">Global mapping</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_connection" role="tab" aria-controls="tabpanel_1_connection" data-tab="connection" tabindex="-1">Connection mapping</a>
</li>
</ul>
<section id="tabpanel_1_datasource" role="tabpanel" data-tab="datasource">

<div class="NOTE">
<h5>Note</h5>
<p><code>NpgsqlDataSource</code> was introduced in Npgsql 7.0, and is the recommended way to manage type mapping. If you're using an older version, see the other methods.</p>
</div>
<pre><code class="lang-c#">var dataSourceBuilder = new NpgsqlDataSourceBuilder(...);
dataSourceBuilder.MapEnum&lt;Mood&gt;();
dataSourceBuilder.MapComposite&lt;InventoryItem&gt;();
await using var dataSource = dataSourceBuilder.Build();
</code></pre>
</section>
<section id="tabpanel_1_global" role="tabpanel" data-tab="global" aria-hidden="true" hidden="hidden">

<p>If you're using an older version of Npgsql which doesn't yet support <code>NpgsqlDataSource</code>, you can configure mappings globally for all connections in your application:</p>
<pre><code class="lang-c#">NpgsqlConnection.GlobalTypeMapper.MapEnum&lt;Mood&gt;();
NpgsqlConnection.GlobalTypeMapper.MapComposite&lt;InventoryItem&gt;();
</code></pre>
<p>For this to work, you must place this code at the beginning of your application, before any other Npgsql API is called. Note that in Npgsql 7.0, global type mappings are obsolete (but still supported) - <code>NpgsqlDataSource</code> is the recommended way to manage type mappings.</p>
</section>
<section id="tabpanel_1_connection" role="tabpanel" data-tab="connection" aria-hidden="true" hidden="hidden">

<div class="NOTE">
<h5>Note</h5>
<p>This mapping method has been removed in Npgsql 7.0.</p>
</div>
<p>Older versions of Npgsql supported configuring a type mapping on an individual connection, as follows:</p>
<pre><code class="lang-c#">var conn = new NpgsqlConnection(...);
conn.TypeMapper.MapEnum&lt;Mood&gt;();
conn.TypeMapper.MapComposite&lt;InventoryItem&gt;();
</code></pre>
</section>
</div>

<p>Whatever the method used, your CLR types <code>Mood</code> and <code>InventoryItem</code> are now mapped to the PostgreSQL types <code>mood</code> and <code>inventory_item</code>.</p>
<h2 id="using-your-mapped-types">Using your mapped types</h2>
<p>Once your mapping is in place, you can read and write your CLR types as usual:</p>
<pre><code class="lang-c#">// Writing
await using (var cmd = new NpgsqlCommand(&quot;INSERT INTO some_table (my_enum, my_composite) VALUES ($1, $2)&quot;, conn))
{
    cmd.Parameters.Add(new() { Value = Mood.Happy });
    cmd.Parameters.Add(new()
    {
        Value = new InventoryItem { ... }
    });
    cmd.ExecuteNonQuery();
}

// Reading
await using (var cmd = new NpgsqlCommand(&quot;SELECT my_enum, my_composite FROM some_table&quot;, conn))
await using (var reader = cmd.ExecuteReader()) {
    reader.Read();
    var enumValue = reader.GetFieldValue&lt;Mood&gt;(0);
    var compositeValue = reader.GetFieldValue&lt;InventoryItem&gt;(1);
}
</code></pre>
<p>Note that your PostgreSQL enum and composites types (<code>mood</code> and <code>inventory_data</code> in the sample above) must be defined in your database before the first connection is created (see <code>CREATE TYPE</code>). If you're creating PostgreSQL types within your program, call <code>NpgsqlConnection.ReloadTypes()</code> to make sure Npgsql becomes properly aware of them.</p>
<h2 id="name-translation">Name translation</h2>
<p>CLR type and field names are usually Pascal case (e.g. <code>InventoryData</code>), whereas in PostgreSQL they are snake case (e.g. <code>inventory_data</code>). To help make the mapping for enums and composites seamless, pluggable name translators are used translate all names. The default translation scheme is <code>NpgsqlSnakeCaseNameTranslator</code>, which maps names like <code>SomeType</code> to <code>some_type</code>, but you can specify others. The default name translator can be set for all your connections via <code>NpgsqlConnection.GlobalTypeMapper.DefaultNameTranslator</code>, or for a specific connection for <code>NpgsqlConnection.TypeMapper.DefaultNameTranslator</code>. You also have the option of specifying a name translator when setting up a mapping:</p>
<pre><code class="lang-c#">NpgsqlConnection.GlobalTypeMapper.MapComposite&lt;InventoryData&gt;(&quot;inventory_data&quot;, new NpgsqlNullNameTranslator());
</code></pre>
<p>Finally, you may control mappings on a field-by-field basis via the <code>[PgName]</code> attribute. This overrides the name translator.</p>
<pre><code class="lang-c#">public enum Mood
{
    [PgName(&quot;depressed&quot;)]
    Sad,
    Ok,
    [PgName(&quot;ebullient&quot;)]
    Happy
}
</code></pre>
<h2 id="reading-and-writing-unmapped-enums">Reading and writing unmapped enums</h2>
<p>In some cases, it may be desirable to interact with PostgreSQL enums without a pre-existing CLR enum type - this is useful mainly if your program doesn't know the database schema and types in advance, and needs to interact with any enum/composite type.</p>
<p>Npgsql allows reading and writing enums as simple strings:</p>
<pre><code class="lang-c#">// Writing enum as string
await using (var cmd = new NpgsqlCommand(&quot;INSERT INTO some_table (my_enum) VALUES ($1)&quot;, conn))
{
    cmd.Parameters.Add(new()
    {
        Value = &quot;Happy&quot;
        DataTypeName = &quot;mood&quot;
    });
    cmd.ExecuteNonQuery();
}

// Reading enum as string
await using (var cmd = new NpgsqlCommand(&quot;SELECT my_enum FROM some_table&quot;, conn))
await using (var reader = cmd.ExecuteReader()) {
    reader.Read();
    var enumValue = reader.GetFieldValue&lt;string&gt;(0);
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/types/enums_and_composites.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © Copyright 2024 The Npgsql Development Team
        </div>
      </div>
    </footer>
  </body>
</html>
