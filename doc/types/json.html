<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Mapping JSON | Npgsql Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Mapping JSON | Npgsql Documentation ">
  
    <link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
    <link rel="manifest" href="../../site.webmanifest">
    <link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/npgsql.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  <meta property="docfx:rel" content="../../">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="mapping-json">Mapping JSON</h1>

<div class="NOTE">
<h5>Note</h5>
<p>If you're using EF Core, please read the page on <a href="../../efcore/mapping/json.html">JSON support in the EF provider</a>. EF has specialized support for JSON beyond what is supported at the lower-level Npgsql layer.</p>
</div>
<p>PostgreSQL has rich, built-in support for storing JSON columns and efficiently performing complex queries operations on them. Newcomers can read more about the PostgreSQL support on <a href="https://www.postgresql.org/docs/current/datatype-json.html">the JSON types page</a>, and on the <a href="https://www.postgresql.org/docs/current/functions-json.html">functions and operators page</a>. Note that the below mapping mechanisms support both the <code>jsonb</code> and <code>json</code> types, although the former is almost always preferred for efficiency and functionality reasons.</p>
<p>Npgsql allows you to map PostgreSQL JSON columns in three different ways:</p>
<ol>
<li>As simple strings</li>
<li>As strongly-typed user-defined types (POCOs)</li>
<li>As System.Text.Json DOM types (JsonDocument or JsonElement, <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-dom#use-jsondocument">see docs</a>)</li>
<li>High-performance JSON parsing with <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-utf8jsonreader">Utf8JsonReader</a></li>
<li>Newtonsoft Json.NET</li>
</ol>
<h2 id="string-mapping">String mapping</h2>
<p>The simplest form of mapping to JSON is as a regular .NET string:</p>
<pre><code class="lang-c#">// Write a string to a json column:
await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = &quot;&quot;&quot;{ &quot;a&quot;: 8, &quot;b&quot;: 9 }&quot;&quot;&quot;, NpgsqlDbType = NpgsqlDbType.Jsonb } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a string:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    Console.WriteLine(reader.GetString(0));
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Note that when writing a string parameter as <code>jsonb</code>, you must specify <code>NpgsqlDbType.Jsonb</code>, otherwise Npgsql sends a <code>text</code> parameter which is incompatible with JSON.</p>
</div>
<p>With this mapping style, you're fully responsible for serializing/deserializing the JSON data yourself (e.g. with System.Text.Json) - Npgsql simply passes your strings to and from PostgreSQL.</p>
<h2 id="poco-mapping">POCO mapping</h2>
<div class="WARNING">
<h5>Warning</h5>
<p>As of Npgsql 8.0, POCO mapping is incompatible with NativeAOT. We plan to improve this, <a href="https://github.com/npgsql/npgsql/issues/5355">please upvote this issue if you're interested</a>.</p>
</div>
<p>If your column JSON contains documents with a stable schema, you can map them to your own .NET types (or POCOs). The provider will use System.Text.Json APIs under the hood to serialize instances of your types to JSON documents before sending them to the database, and to deserialize documents coming back from the database. This effectively allows mapping an arbitrary .NET type - or object graph - to a single column in the database.</p>
<p>Starting with Npgsql 8.0, to use this feature, you must first enable it by calling &lt;xref:Npgsql.INpgsqlTypeMapperExtensions.EnableDynamicJson&gt; on your <a class="xref" href="../api/Npgsql.NpgsqlDataSourceBuilder.html">NpgsqlDataSourceBuilder</a>, or, if you're not yet using data sources, on <code>NpgsqlConnection.GlobalTypeMapper</code>:</p>
<div class="tabGroup" id="tabgroup_bHGHmlrG6S">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S_datasource" role="tab" aria-controls="tabpanel_bHGHmlrG6S_datasource" data-tab="datasource" tabindex="0" aria-selected="true">NpgsqlDataSource</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S_global" role="tab" aria-controls="tabpanel_bHGHmlrG6S_global" data-tab="global" tabindex="-1">Global mapping</a>
</li>
</ul>
<section id="tabpanel_bHGHmlrG6S_datasource" role="tabpanel" data-tab="datasource">

<div class="NOTE">
<h5>Note</h5>
<p><code>NpgsqlDataSource</code> was introduced in Npgsql 7.0, and is the recommended way to manage type mapping. If you're using an older version, see the other methods.</p>
</div>
<pre><code class="lang-c#">var dataSourceBuilder = new NpgsqlDataSourceBuilder(...);
dataSourceBuilder.EnableDynamicJson();
await using var dataSource = dataSourceBuilder.Build();
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S_global" role="tabpanel" data-tab="global" aria-hidden="true" hidden="hidden">

<p>If you're not yet using <code>NpgsqlDataSource</code>, you can configure mappings globally for all connections in your application:</p>
<pre><code class="lang-c#">NpgsqlConnection.GlobalTypeMapper.EnableDynamicJson();
</code></pre>
<p>For this to work, you must place this code at the beginning of your application, before any other Npgsql API is called. Note that in Npgsql 7.0, global type mappings are obsolete (but still supported) - <code>NpgsqlDataSource</code> is the recommended way to manage type mappings.</p>
</section>
</div>

<p>Once you've enabled the feature, you can simply read and write instances of your POCOs directly; when writing, specify <code>NpgsqlDbType.Jsonb</code> to let Npgsql know you intend for it to get sent as JSON data:</p>
<pre><code class="lang-c#">// Write a POCO to a jsonb column:
var myPoco1 = new MyPoco { A = 8, B = 9 };

await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = myPoco1, NpgsqlDbType = NpgsqlDbType.Jsonb } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a POCO:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    var myPoco2 = reader.GetFieldValue&lt;MyPoco&gt;(0);
    Console.WriteLine(myPoco2.A);
}

class MyPoco
{
    public int A { get; set; }
    public int B { get; set; }
}
</code></pre>
<p>This mapping method is quite powerful, allowing you to read and write nested graphs of objects and arrays to PostgreSQL without having to deal with serialization yourself.</p>
<h2 id="systemtextjson-dom-types">System.Text.Json DOM types</h2>
<p>There are cases in which mapping JSON data to POCOs isn't appropriate; for example, your JSON column may not contain a fixed schema and must be inspected to see what it contains; nor these cases, Npgsql supports mapping JSON data to <a href="https://docs.microsoft.com/dotnet/api/system.text.json.jsondocument">JsonDocument</a> or <a href="https://docs.microsoft.com/dotnet/api/system.text.json.jsonelement">JsonElement</a> (<a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-dom#use-jsondocument">see docs</a>):</p>
<pre><code class="lang-c#">var jsonDocument = JsonDocument.Parse(&quot;&quot;&quot;{ &quot;a&quot;: 8, &quot;b&quot;: 9 }&quot;&quot;&quot;);

// Write a JsonDocument:
await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = jsonDocument } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a JsonDocument:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    var document = reader.GetFieldValue&lt;JsonDocument&gt;(0);
    Console.WriteLine(document.RootElement.GetProperty(&quot;a&quot;).GetInt32());
}
</code></pre>
<h2 id="high-performance-json-parsing-with-utf8jsonreader">High-performance JSON parsing with Utf8JsonReader</h2>
<p>If you're writing a very performance-sensitive application, using System.Text.Json to deserialize to POCOs or JsonDocument may incur too much overhead. If that's the case, you can use System.Text.Json's <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-utf8jsonreader">Utf8JsonReader</a> to parse JSON data from the database. Utf8JsonReader provides a low-level, forward-only API to parse the JSON data, one token at a time.</p>
<p>Utf8JsonReader requires JSON data as raw, UTF8-encoded binary data; fortunately, Npgsql allows reading <code>jsonb</code> as binary data, and if your PostgreSQL <code>client_encoding</code> is set to UTF8 (the default), you can feed data directly from PostgreSQL to Utf8JsonReader:</p>
<pre><code class="lang-c#">await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    ParseJson(reader.GetFieldValue&lt;byte[]&gt;(0));
}

void ParseJson(byte[] utf8Data)
{
    var jsonReader = new Utf8JsonReader(utf8Data);
    // ... parse the data with jsonReader
}
</code></pre>
<p>Note that the above works well for small JSON columns; if you have large columns (above ~8k), consider streaming the JSON data instead. This can be done by passing <code>CommandBehavior.SequentialAccess</code> to <code>ExecuteReaderAsync</code>, and then calling <code>reader.GetStream()</code> on NpgsqlDataReader instead of <code>GetFieldValue&lt;byte[]&gt;</code>. To process streaming data with Utf8JsonReader, <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-utf8jsonreader#read-from-a-stream-using-utf8jsonreader">see these docs</a>.</p>
<h2 id="newtonsoftjson">Newtonsoft.JSON</h2>
<p>System.Text.Json is the built-in, standard way to handle JSON in modern .NET. However, some users still prefer using Newtonoft Json.NET, and Npgsql includes support for that.</p>
<p>To use Json.NET, add the <a href="https://www.nuget.org/packages/Npgsql.Json.NET">Npgsql.Json.NET package</a> to your project, and enable the plugin as follows:</p>
<div class="tabGroup" id="tabgroup_bHGHmlrG6S-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-1_datasource" role="tab" aria-controls="tabpanel_bHGHmlrG6S-1_datasource" data-tab="datasource" tabindex="0" aria-selected="true">NpgsqlDataSource</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-1_global" role="tab" aria-controls="tabpanel_bHGHmlrG6S-1_global" data-tab="global" tabindex="-1">Global mapping</a>
</li>
</ul>
<section id="tabpanel_bHGHmlrG6S-1_datasource" role="tabpanel" data-tab="datasource">

<div class="NOTE">
<h5>Note</h5>
<p><code>NpgsqlDataSource</code> was introduced in Npgsql 7.0, and is the recommended way to manage type mapping. If you're using an older version, see the other methods.</p>
</div>
<pre><code class="lang-c#">var dataSourceBuilder = new NpgsqlDataSourceBuilder(...);
dataSourceBuilder.UseJsonNet();
await using var dataSource = dataSourceBuilder.Build();
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S-1_global" role="tabpanel" data-tab="global" aria-hidden="true" hidden="hidden">

<p>If you're using an older version of Npgsql which doesn't yet support <code>NpgsqlDataSource</code>, you can configure mappings globally for all connections in your application:</p>
<pre><code class="lang-c#">NpgsqlConnection.GlobalTypeMapper.UseJsonNet();
</code></pre>
<p>For this to work, you must place this code at the beginning of your application, before any other Npgsql API is called. Note that in Npgsql 7.0, global type mappings are obsolete (but still supported) - <code>NpgsqlDataSource</code> is the recommended way to manage type mappings.</p>
</section>
</div>

<p>Once you've enabled the feature, you can simply read and write instances of your POCOs directly; when writing, specify <code>NpgsqlDbType.Jsonb</code> to let Npgsql know you intend for it to get sent as JSON data:</p>
<pre><code class="lang-c#">// Write a POCO to a jsonb column:
var myPoco1 = new MyPoco { A = 8, B = 9 };

await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = myPoco1, NpgsqlDbType = NpgsqlDbType.Jsonb } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a POCO:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    var myPoco2 = reader.GetFieldValue&lt;MyPoco&gt;(0);
    Console.WriteLine(myPoco2.A);
}

class MyPoco
{
    public int A { get; set; }
    public int B { get; set; }
}
</code></pre>
<p>The plugin also allows you to read JObject/JArray for weakly-typed DOM mapping.</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/types/json.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      © Copyright 2023 The Npgsql Development Team
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
