<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Mapping JSON | Npgsql Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Mapping JSON | Npgsql Documentation ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/types/json.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../img/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="mapping-json">Mapping JSON</h1>

<div class="NOTE">
<h5>Note</h5>
<p>If you're using EF Core, please read the page on <a href="../../efcore/mapping/json.html">JSON support in the EF provider</a>. EF has specialized support for JSON beyond what is supported at the lower-level Npgsql layer.</p>
</div>
<p>PostgreSQL has rich, built-in support for storing JSON columns and efficiently performing complex queries operations on them. Newcomers can read more about the PostgreSQL support on <a href="https://www.postgresql.org/docs/current/datatype-json.html">the JSON types page</a>, and on the <a href="https://www.postgresql.org/docs/current/functions-json.html">functions and operators page</a>. Note that the below mapping mechanisms support both the <code>jsonb</code> and <code>json</code> types, although the former is almost always preferred for efficiency and functionality reasons.</p>
<p>Npgsql allows you to map PostgreSQL JSON columns in three different ways:</p>
<ol>
<li>As simple strings</li>
<li>As strongly-typed user-defined types (POCOs)</li>
<li>As System.Text.Json DOM types (JsonDocument or JsonElement, <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-dom#use-jsondocument">see docs</a>)</li>
<li>High-performance JSON parsing with <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-utf8jsonreader">Utf8JsonReader</a></li>
<li>Newtonsoft Json.NET</li>
</ol>
<h2 id="string-mapping">String mapping</h2>
<p>The simplest form of mapping to JSON is as a regular .NET string:</p>
<pre><code class="lang-csharp">// Write a string to a json column:
await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = &quot;&quot;&quot;{ &quot;a&quot;: 8, &quot;b&quot;: 9 }&quot;&quot;&quot;, NpgsqlDbType = NpgsqlDbType.Jsonb } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a string:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    Console.WriteLine(reader.GetString(0));
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Note that when writing a string parameter as <code>jsonb</code>, you must specify <code>NpgsqlDbType.Jsonb</code>, otherwise Npgsql sends a <code>text</code> parameter which is incompatible with JSON.</p>
</div>
<p>With this mapping style, you're fully responsible for serializing/deserializing the JSON data yourself (e.g. with System.Text.Json) - Npgsql simply passes your strings to and from PostgreSQL.</p>
<h2 id="poco-mapping">POCO mapping</h2>
<div class="WARNING">
<h5>Warning</h5>
<p>As of Npgsql 8.0, POCO mapping is incompatible with NativeAOT. We plan to improve this, <a href="https://github.com/npgsql/npgsql/issues/5355">please upvote this issue if you're interested</a>.</p>
</div>
<p>If your column JSON contains documents with a stable schema, you can map them to your own .NET types (or POCOs). The provider will use System.Text.Json APIs under the hood to serialize instances of your types to JSON documents before sending them to the database, and to deserialize documents coming back from the database. This effectively allows mapping an arbitrary .NET type - or object graph - to a single column in the database.</p>
<p>Starting with Npgsql 8.0, to use this feature, you must first enable it by calling <a class="xref" href="../api/Npgsql.TypeMapping.INpgsqlTypeMapper.html#Npgsql_TypeMapping_INpgsqlTypeMapper_EnableDynamicJson_">EnableDynamicJson</a> on your <a class="xref" href="../api/Npgsql.NpgsqlDataSourceBuilder.html">NpgsqlDataSourceBuilder</a>, or, if you're not yet using data sources, on <code>NpgsqlConnection.GlobalTypeMapper</code>:</p>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_datasource" role="tab" aria-controls="tabpanel_1_datasource" data-tab="datasource" tabindex="0" aria-selected="true">NpgsqlDataSource</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_global" role="tab" aria-controls="tabpanel_1_global" data-tab="global" tabindex="-1">Global mapping</a>
</li>
</ul>
<section id="tabpanel_1_datasource" role="tabpanel" data-tab="datasource">

<div class="NOTE">
<h5>Note</h5>
<p><code>NpgsqlDataSource</code> was introduced in Npgsql 7.0, and is the recommended way to manage type mapping. If you're using an older version, see the other methods.</p>
</div>
<pre><code class="lang-csharp">var dataSourceBuilder = new NpgsqlDataSourceBuilder(...);
dataSourceBuilder.EnableDynamicJson();
await using var dataSource = dataSourceBuilder.Build();
</code></pre>
</section>
<section id="tabpanel_1_global" role="tabpanel" data-tab="global" aria-hidden="true" hidden="hidden">

<p>If you're not yet using <code>NpgsqlDataSource</code>, you can configure mappings globally for all connections in your application:</p>
<pre><code class="lang-csharp">NpgsqlConnection.GlobalTypeMapper.EnableDynamicJson();
</code></pre>
<p>For this to work, you must place this code at the beginning of your application, before any other Npgsql API is called. Note that in Npgsql 7.0, global type mappings are obsolete (but still supported) - <code>NpgsqlDataSource</code> is the recommended way to manage type mappings.</p>
</section>
</div>

<p>Once you've enabled the feature, you can simply read and write instances of your POCOs directly; when writing, specify <code>NpgsqlDbType.Jsonb</code> to let Npgsql know you intend for it to get sent as JSON data:</p>
<pre><code class="lang-csharp">// Write a POCO to a jsonb column:
var myPoco1 = new MyPoco { A = 8, B = 9 };

await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = myPoco1, NpgsqlDbType = NpgsqlDbType.Jsonb } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a POCO:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    var myPoco2 = reader.GetFieldValue&lt;MyPoco&gt;(0);
    Console.WriteLine(myPoco2.A);
}

class MyPoco
{
    public int A { get; set; }
    public int B { get; set; }
}
</code></pre>
<p>This mapping method is quite powerful, allowing you to read and write nested graphs of objects and arrays to PostgreSQL without having to deal with serialization yourself.</p>
<h2 id="systemtextjson-dom-types">System.Text.Json DOM types</h2>
<p>There are cases in which mapping JSON data to POCOs isn't appropriate; for example, your JSON column may not contain a fixed schema and must be inspected to see what it contains; for these cases, Npgsql supports mapping JSON data to <a href="https://docs.microsoft.com/dotnet/api/system.text.json.jsondocument">JsonDocument</a> or <a href="https://docs.microsoft.com/dotnet/api/system.text.json.jsonelement">JsonElement</a> (<a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-dom#use-jsondocument">see docs</a>):</p>
<pre><code class="lang-csharp">var jsonDocument = JsonDocument.Parse(&quot;&quot;&quot;{ &quot;a&quot;: 8, &quot;b&quot;: 9 }&quot;&quot;&quot;);

// Write a JsonDocument:
await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = jsonDocument } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a JsonDocument:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    var document = reader.GetFieldValue&lt;JsonDocument&gt;(0);
    Console.WriteLine(document.RootElement.GetProperty(&quot;a&quot;).GetInt32());
}
</code></pre>
<h2 id="high-performance-json-parsing-with-utf8jsonreader">High-performance JSON parsing with Utf8JsonReader</h2>
<p>If you're writing a very performance-sensitive application, using System.Text.Json to deserialize to POCOs or JsonDocument may incur too much overhead. If that's the case, you can use System.Text.Json's <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-utf8jsonreader">Utf8JsonReader</a> to parse JSON data from the database. Utf8JsonReader provides a low-level, forward-only API to parse the JSON data, one token at a time.</p>
<p>Utf8JsonReader requires JSON data as raw, UTF8-encoded binary data; fortunately, Npgsql allows reading <code>jsonb</code> as binary data, and if your PostgreSQL <code>client_encoding</code> is set to UTF8 (the default), you can feed data directly from PostgreSQL to Utf8JsonReader:</p>
<pre><code class="lang-csharp">await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    ParseJson(reader.GetFieldValue&lt;byte[]&gt;(0));
}

void ParseJson(byte[] utf8Data)
{
    var jsonReader = new Utf8JsonReader(utf8Data);
    // ... parse the data with jsonReader
}
</code></pre>
<p>Note that the above works well for small JSON columns; if you have large columns (above ~8k), consider streaming the JSON data instead. This can be done by passing <code>CommandBehavior.SequentialAccess</code> to <code>ExecuteReaderAsync</code>, and then calling <code>reader.GetStream()</code> on NpgsqlDataReader instead of <code>GetFieldValue&lt;byte[]&gt;</code>. To process streaming data with Utf8JsonReader, <a href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/use-utf8jsonreader#read-from-a-stream-using-utf8jsonreader">see these docs</a>.</p>
<h2 id="newtonsoftjson">Newtonsoft.JSON</h2>
<p>System.Text.Json is the built-in, standard way to handle JSON in modern .NET. However, some users still prefer using Newtonoft Json.NET, and Npgsql includes support for that.</p>
<p>To use Json.NET, add the <a href="https://www.nuget.org/packages/Npgsql.Json.NET">Npgsql.Json.NET package</a> to your project, and enable the plugin as follows:</p>
<div class="tabGroup" id="tabgroup_2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_2_datasource" role="tab" aria-controls="tabpanel_2_datasource" data-tab="datasource" tabindex="0" aria-selected="true">NpgsqlDataSource</a>
</li>
<li role="presentation">
<a href="#tabpanel_2_global" role="tab" aria-controls="tabpanel_2_global" data-tab="global" tabindex="-1">Global mapping</a>
</li>
</ul>
<section id="tabpanel_2_datasource" role="tabpanel" data-tab="datasource">

<div class="NOTE">
<h5>Note</h5>
<p><code>NpgsqlDataSource</code> was introduced in Npgsql 7.0, and is the recommended way to manage type mapping. If you're using an older version, see the other methods.</p>
</div>
<pre><code class="lang-csharp">var dataSourceBuilder = new NpgsqlDataSourceBuilder(...);
dataSourceBuilder.UseJsonNet();
await using var dataSource = dataSourceBuilder.Build();
</code></pre>
</section>
<section id="tabpanel_2_global" role="tabpanel" data-tab="global" aria-hidden="true" hidden="hidden">

<p>If you're using an older version of Npgsql which doesn't yet support <code>NpgsqlDataSource</code>, you can configure mappings globally for all connections in your application:</p>
<pre><code class="lang-csharp">NpgsqlConnection.GlobalTypeMapper.UseJsonNet();
</code></pre>
<p>For this to work, you must place this code at the beginning of your application, before any other Npgsql API is called. Note that in Npgsql 7.0, global type mappings are obsolete (but still supported) - <code>NpgsqlDataSource</code> is the recommended way to manage type mappings.</p>
</section>
</div>

<p>Once you've enabled the feature, you can simply read and write instances of your POCOs directly; when writing, specify <code>NpgsqlDbType.Jsonb</code> to let Npgsql know you intend for it to get sent as JSON data:</p>
<pre><code class="lang-csharp">// Write a POCO to a jsonb column:
var myPoco1 = new MyPoco { A = 8, B = 9 };

await using var command1 = new NpgsqlCommand(&quot;INSERT INTO test (data) VALUES ($1)&quot;, conn)
{
    Parameters = { new() { Value = myPoco1, NpgsqlDbType = NpgsqlDbType.Jsonb } }
};
await command1.ExecuteNonQueryAsync();

// Read jsonb data as a POCO:
await using var command2 = new NpgsqlCommand(&quot;SELECT data FROM test&quot;, conn);
await using var reader = await command2.ExecuteReaderAsync();
while (await reader.ReadAsync())
{
    var myPoco2 = reader.GetFieldValue&lt;MyPoco&gt;(0);
    Console.WriteLine(myPoco2.A);
}

class MyPoco
{
    public int A { get; set; }
    public int B { get; set; }
}
</code></pre>
<p>The plugin also allows you to read JObject/JArray for weakly-typed DOM mapping.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/types/json.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © Copyright 2024 The Npgsql Development Team
        </div>
      </div>
    </footer>
  </body>
</html>
