<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Security and Encryption | Npgsql Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Security and Encryption | Npgsql Documentation ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/security.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../img/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="security-and-encryption">Security and Encryption</h1>

<h2 id="password-management">Password management</h2>
<p>The simplest way to log into PostgreSQL is by specifying a <code>Username</code> and a <code>Password</code> in your connection string. Depending on how your PostgreSQL is configured (in the <code>pg_hba.conf</code> file), Npgsql will send the password in MD5 or in cleartext (not recommended).</p>
<p>If a <code>Password</code> is not specified and your PostgreSQL is configured to request a password, Npgsql will look for a <a href="https://www.postgresql.org/docs/current/static/libpq-pgpass.html">standard PostgreSQL password file</a>. If you specify the <code>Passfile</code> connection string parameter, the file it specifies will be used. If that parameter isn't defined, Npgsql will look under the path taken from <code>PGPASSFILE</code> environment variable. If the environment variable isn't defined, Npgsql will fall back to the system-dependent default directory which is <code>$HOME/.pgpass</code> for Unix and <code>%APPDATA%\postgresql\pgpass.conf</code> for Windows.</p>
<h3 id="auth-token-rotation-and-dynamic-password">Auth token rotation and dynamic password</h3>
<p>In some cloud scenarios, logging into PostgreSQL is done with an auth token that is rotated every time interval (e.g. one hour). Npgsql has a built-in periodic password provider mechanism, which allows using an up-to-date access token with zero effort:</p>
<pre><code class="lang-csharp">var dataSourceBuilder = new NpgsqlDataSourceBuilder(...);
dataSourceBuilder.UsePasswordProvider(
    passwordProvider: _ =&gt; throw new NotSupportedException(),
    passwordProviderAsync: (builder, token) =&gt; /* code to fetch the new access token */);
await using var dataSource = dataSourceBuilder.Build();
</code></pre>
<p>Every time a new physical connection needs to be opened to PostgreSQL, either the synchronous <code>passwordProvider</code> or the asynchronous <code>passwordProviderAsync</code> will be called (depending whether you used <code>Open()</code> or <code>OpenAsync()</code>). Since modern .NET applications are encouraged to always use asynchronous I/O, it's good practice to simply throw in the synchronous password provider, as above.</p>
<p>Note that since the password provider is invoked <em>every</em> time a physical connection is opened, it shouldn't take too long; typically, this would call into a cloud provider API (e.g. Azure Managed Identity), which itself implements a caching mechanism. However, if no such caching is done and the code could take a while, you can instead instruct Npgsql to cache the auth token for a given amount of time:</p>
<pre><code class="lang-csharp">dataSourceBuilder.UsePeriodicPasswordProvider(
    (settings, cancellationToken) =&gt;  /* async code to fetch the new access token */,
    TimeSpan.FromMinutes(55), // Interval for refreshing the token
    TimeSpan.FromSeconds(5)); // Interval for retrying after a refresh failure
</code></pre>
<p>Finally, if you already have code running when the auth token changes, you can simply inject it manually at any time into a working data source:</p>
<pre><code class="lang-csharp">dataSource.Password = &lt;new password&gt;;
</code></pre>
<p>Any physical connection that's opened after this point will use the newly-injected password.</p>
<h2 id="encryption-ssltls">Encryption (SSL/TLS)</h2>
<p>By default PostgreSQL connections are unencrypted, but you can turn on SSL/TLS encryption if you wish. First, you have to set up your PostgreSQL to receive SSL/TLS connections <a href="http://www.postgresql.org/docs/current/static/ssl-tcp.html">as described here</a>. Once that's done, specify <code>SSL Mode</code> in your connection string as detailed below.</p>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_tabid-1" role="tab" aria-controls="tabpanel_1_tabid-1" data-tab="tabid-1" tabindex="0" aria-selected="true">Version 6.0+</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_tabid-2" role="tab" aria-controls="tabpanel_1_tabid-2" data-tab="tabid-2" tabindex="-1">Older versions</a>
</li>
</ul>
<section id="tabpanel_1_tabid-1" role="tabpanel" data-tab="tabid-1">

<p>Starting with 6.0, the following <code>SSL Mode</code> values are supported (see the <a href="https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-SSLMODE-STATEMENTS">PostgreSQL docs</a> for more details):</p>
<table>
<thead>
<tr>
<th>SSL Mode</th>
<th>Eavesdropping protection</th>
<th>Man-in-the-middle protection</th>
<th>Statement</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disable</td>
<td>No</td>
<td>No</td>
<td>I don't care about security, and I don't want to pay the overhead of encryption.</td>
</tr>
<tr>
<td>Allow</td>
<td>Maybe</td>
<td>No</td>
<td>I don't care about security, but I will pay the overhead of encryption if the server insists on it.</td>
</tr>
<tr>
<td>Prefer (default)</td>
<td>Maybe</td>
<td>No</td>
<td>I don't care about encryption, but I wish to pay the overhead of encryption if the server supports it.</td>
</tr>
<tr>
<td>Require<sup>1</sup></td>
<td>Yes</td>
<td>No</td>
<td>I want my data to be encrypted, and I accept the overhead. I trust that the network will make sure I always connect to the server I want.</td>
</tr>
<tr>
<td>VerifyCA</td>
<td>Yes</td>
<td>Depends on CA policy</td>
<td>I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server that I trust.</td>
</tr>
<tr>
<td>VerifyFull</td>
<td>Yes</td>
<td>Yes</td>
<td>I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server I trust, and that it's the one I specify.</td>
</tr>
</tbody>
</table>
<p><sup>1</sup> Prior to Npgsql 8.0, <code>SSL Mode=Require</code> required explicitly setting <code>Trust Server Certificate=true</code> as well, to make it explicit that the server certificate isn't validated. Starting with 8.0, <code>Trust Server Certificate=true</code> is no longer required and does nothing.</p>
<p>The default mode in 6.0+ is <code>Prefer</code>, which allows SSL but does not require it, and does not validate certificates.</p>
</section>
<section id="tabpanel_1_tabid-2" role="tabpanel" data-tab="tabid-2" aria-hidden="true" hidden="hidden">

<p>Versions prior to 6.0 supported the following <code>SSL Mode</code> values:</p>
<table>
<thead>
<tr>
<th>SSL Mode</th>
<th>Eavesdropping protection</th>
<th>Man-in-the-middle protection</th>
<th>Statement</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disable</td>
<td>No</td>
<td>No</td>
<td>I don't care about security, and I don't want to pay the overhead of encryption.</td>
</tr>
<tr>
<td>Prefer</td>
<td>Maybe</td>
<td>Maybe</td>
<td>I don't care about encryption, but I wish to pay the overhead of encryption if the server supports it.</td>
</tr>
<tr>
<td>Require</td>
<td>Yes</td>
<td>Yes</td>
<td>I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server I trust, and that it's the one I specify.</td>
</tr>
</tbody>
</table>
<p>The default mode prior to 6.0 was <code>Disable</code>.</p>
<p>To disable certificate validation when using <code>Require</code>, set <code>Trust Server Certificate</code> to true; this allows connecting to servers with e.g. self-signed certificates, while still requiring encryption.</p>
</section>
</div>
<h3 id="advanced-server-certificate-validation">Advanced server certificate validation</h3>
<p>If the root CA of the server certificate isn't installed in your machine's CA store, validation will fail. Either install the certificate in your machine's CA store, or point to it via the <code>Root Certificate</code> connection string parameter or via the <code>PGSSLROOTCERT</code> environment variable.</p>
<p>Note that Npgsql does not perform certificate revocation validation by default, since this is an optional extension not implemented by all providers and CAs. To turn on certificate revocation validation, specify <code>Check Certificate Revocation=true</code> on the connection string.</p>
<p>Finally, if the above options aren't sufficient for your scenario, you can call <a class="xref" href="api/Npgsql.NpgsqlDataSourceBuilder.html#Npgsql_NpgsqlDataSourceBuilder_UseUserCertificateValidationCallback_">NpgsqlDataSourceBuilder.UseUserCertificateValidationCallback</a> to provide your custom server certificate validation logic (this gets set on the underlying .NET <a href="https://docs.microsoft.com/dotnet/api/system.net.security.sslstream.-ctor#System_Net_Security_SslStream__ctor_System_IO_Stream_System_Boolean_System_Net_Security_RemoteCertificateValidationCallback_System_Net_Security_LocalCertificateSelectionCallback_"><code>SslStream</code></a>).</p>
<h3 id="client-certificates">Client certificates</h3>
<p>PostgreSQL may be configured to require valid certificates from connecting clients for authentication. Npgsql automatically sends client certificates specified in the following places:</p>
<ul>
<li>The <code>SSL Certificate</code> connection string parameter.</li>
<li>The <code>PGSSLCERT</code> environment variable.</li>
<li>The default locations of <code>~/.postgresql/postgresql.crt</code> (on Unix) or <code>%APPDATA%\postgresql\postgresql.crt</code> (on Windows)</li>
</ul>
<p>To provide a password for a client certificate, set either the <code>SSL Password</code> (6.0 and higher) or <code>Client Certificate Key</code> (5.0 and lower) connection string parameter.</p>
<p>Finally, you can call <a class="xref" href="api/Npgsql.NpgsqlDataSourceBuilder.html#Npgsql_NpgsqlDataSourceBuilder_UseClientCertificate_">NpgsqlDataSourceBuilder.UseClientCertificate</a>, <a class="xref" href="api/Npgsql.NpgsqlDataSourceBuilder.html#Npgsql_NpgsqlDataSourceBuilder_UseClientCertificates_">NpgsqlDataSourceBuilder.UseClientCertificates</a> or <a class="xref" href="api/Npgsql.NpgsqlDataSourceBuilder.html#Npgsql_NpgsqlDataSourceBuilder_UseClientCertificatesCallback_">NpgsqlDataSourceBuilder.UseClientCertificatesCallback</a> to programmatically provide a certificate, multiple certificates or a callback which returns certificates (this works like on the underlying .NET <a href="https://docs.microsoft.com/dotnet/api/system.net.security.sslstream.-ctor#System_Net_Security_SslStream__ctor_System_IO_Stream_System_Boolean_System_Net_Security_RemoteCertificateValidationCallback_System_Net_Security_LocalCertificateSelectionCallback_"><code>SslStream</code></a>).</p>
<div class="NOTE">
<h5>Note</h5>
<p>Npgsql supports .PFX and .PEM certificates starting with 6.0. Previously, only .PFX certificates were supported.</p>
</div>
<h2 id="password-less-authentication-gsssspikerberos">Password-less authentication (GSS/SSPI/Kerberos)</h2>
<p>Logging in with a username and password may not be ideal, since your application must have access to your password, and raise questions around secret management. An alternate way of authenticating is to use GSS or SSPI to negotiate Kerberos. The advantage of this method is that authentication is handed off to your operating system, using your already-open login session. Your application never needs to handle a password. You can use this method for a Kerberos login, Windows Active Directory or a local Windows session.</p>
<p>Instructions on setting up Kerberos and SSPI are available in the <a href="http://www.postgresql.org/docs/current/static/auth-methods.html">PostgreSQL auth methods docs</a>. Some more instructions for SSPI are <a href="https://wiki.postgresql.org/wiki/Configuring_for_single_sign-on_using_SSPI_on_Windows">available here</a>.</p>
<p>Once your PostgreSQL is configured correctly, it will require GSS/SSPI authentication from Npgsql at login, and you can simply drop the <code>Password</code> parameter from the connection string. However, Npgsql must still send a username to PostgreSQL. If you specify a <code>Username</code> connection string parameter, Npgsql will send that as usual. If you omit it, Npgsql will attempt to detect your system username, including the Kerberos realm. Note that by default, PostgreSQL expects your Kerberos realm to be sent in your username (e.g. <code>username@REALM</code>); you can have Npgsql detect the realm by setting <code>Include Realm</code> to true in your connection string. Alternatively, you can disable add <code>include_realm=0</code> in your PostgreSQL's pg_hba.conf entry, which will make it strip the realm. You always have the possibility of explicitly specifying the username sent to PostgreSQL yourself.</p>
<p>Note that in versions of Npgsql prior to 8.0, use of GSS/SSPI authentication requires that <code>Integrated Security=true</code> be specified on the connection string. This requirement has been removed in Npgsql 8.0.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/security.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © Copyright 2024 The Npgsql Development Team
        </div>
      </div>
    </footer>
  </body>
</html>
