<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Logical and Physical Replication | Npgsql Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Logical and Physical Replication | Npgsql Documentation ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/replication.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="logical-and-physical-replication">Logical and Physical Replication</h1>

<p>Replication allows a client to receive a continuous stream of updates from a PostgreSQL database, providing a near-realtime view of all changes as they occur. While this feature was originally developed to keep PostgreSQL standby replicas in sync with a primary, it can be used by arbitrary client applications.</p>
<p>Replication can be used anywhere where a constant change feed of database changes is required; for example, an external application can be notified in near-realtime of any changes that occurred in a particular database table. This can be useful for external auditing purposes, for replicating certain data somewhere else, for implement the outbox pattern (see <a href="#additional-resources">Additional resources</a> below), and various other usages.</p>
<p>Npgsql provides a 1st-class API for writing .NET replication clients, detailed below. While PostgreSQL supports both logical and physical replication, in the majority of cases .NET applications will want to use logical replication.</p>
<h2 id="logical-replication">Logical replication</h2>
<p>Logical replication is a means to stream messages generated by PostgreSQL <a href="https://www.postgresql.org/docs/current/logicaldecoding.html">logical decoding</a> plugins to a client.
The default implementation that is used by PostgreSQL itself to perform logical server to server replication is the Logical Streaming Replication Protocol which uses the <code>pgoutput</code> plugin, but PostgreSQL supports streaming messages generated by other plugins too and Npgsql supports receiving those.</p>
<h3 id="general-setup">General setup</h3>
<p>To set up logical replication, follow the <a href="https://www.postgresql.org/docs/current/logical-replication-quick-setup.html">quick setup instructions</a> in the PostgreSQL docs (note that a SUBSCRIPTION isn't required since the client isn't PostgreSQL):</p>
<p>Enable logical replication in your <code>postgresql.conf</code> file:</p>
<pre><code class="lang-ini">wal_level = logical
</code></pre>
<p>Set up a replication user in your <a href="https://www.postgresql.org/docs/current/auth-pg-hba-conf.html"><code>pg_hba.conf</code></a> file:</p>
<pre><code class="lang-text">host     replication     repuser     0.0.0.0/0     md5
</code></pre>
<p>The user <code>repuser</code> must exist in your cluster and either be a superuser or have the replication attribute set. See <a href="https://www.postgresql.org/docs/current/sql-createrole.html">CREATE ROLE docs</a>.</p>
<h3 id="logical-streaming-replication-protocol-pgoutput-plugin">Logical Streaming Replication Protocol (pgoutput plugin)</h3>
<p>The modern, recommended way to perform logical replication was introduced in PostgreSQL 10 - <a href="https://www.postgresql.org/docs/current/logical-replication.html">see the PostgreSQL documentation</a>. This method, using the built-in pgoutput replication plugin, streams efficient, binary messages to represent database updates such as INSERT, UPDATE and DELETE (<a href="https://www.postgresql.org/docs/current/protocol-logicalrep-message-formats.html">see the full list</a>); Npgsql exposes these messages as an <code>IAsyncEnumerable</code> which can easily be enumerated and consumed.</p>
<p><a href="https://www.postgresql.org/docs/current/sql-createpublication.html">Create a publication</a>, which defines the group of tables in the database you wish to replicate:</p>
<pre><code class="lang-sql">CREATE PUBLICATION blog_pub FOR TABLE blogs;
</code></pre>
<p>Create a replication slot, which will hold the state of the replication stream:</p>
<pre><code class="lang-sql">SELECT * FROM pg_create_logical_replication_slot('blog_slot', 'pgoutput');
</code></pre>
<p>If your application goes down, the slot persistently records the last data streamed to it, and allows resuming the application at the point where it left off.</p>
<p>At this point, everything is ready to start replicating! Create this simple .NET program with Npgsql:</p>
<pre><code class="lang-csharp">await using var conn = new LogicalReplicationConnection(&quot;&lt;connection_string&gt;&quot;);
await conn.Open();

var slot = new PgOutputReplicationSlot(&quot;blog_slot&quot;);

// The following will loop until the cancellation token is triggered, and will print message types coming from PostgreSQL:
var cancellationTokenSource = new CancellationTokenSource();
await foreach (var message in conn.StartReplication(
    slot, new PgOutputReplicationOptions(&quot;blog_pub&quot;, 1), cancellationTokenSource.Token))
{
    Console.WriteLine($&quot;Received message type: {message.GetType().Name}&quot;);

    // Always call SetReplicationStatus() or assign LastAppliedLsn and LastFlushedLsn individually
    // so that Npgsql can inform the server which WAL files can be removed/recycled.
    conn.SetReplicationStatus(message.WalEnd);
}
</code></pre>
<p>For example, if you insert a new row into your <code>blogs</code> table, you should see the following output:</p>
<pre><code class="lang-output">Received message type: BeginMessage
Received message type: RelationMessage
Received message type: InsertMessage
Received message type: CommitMessage
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>Npgsql internally recycles the message instances it hands out. It is an error to use a message received from <code>StartReplication</code> once the next message has been read.</p>
</div>
<p>The above was just a minimal &quot;getting started&quot; guide for logical replication - many additional configuration options and modes exist as well. Consult the PostgreSQL documentation for more details.</p>
<h3 id="test-decoding-test_decoding-plugin">Test decoding (test_decoding plugin)</h3>
<p>An additional logical replication plugin which Npgsql supports is <code>test_decoding</code>. This plugin outputs textual representations of events, which are less efficient and need to be parsed; it is meant for testing that replication works rather than for building robust production apps. However, it can still be useful in some scenarios, especially in older PostgreSQL versions where <code>pgoutput</code> wasn't yet introduced.</p>
<p>To use <code>test_decoding</code>, first create a logical replication slot with <code>test_decoding</code> as the plugin type.</p>
<pre><code class="lang-sql">SELECT * FROM pg_create_logical_replication_slot('blog_slot', 'test_decoding');
</code></pre>
<p>After that use the following:</p>
<pre><code class="lang-csharp">await using var conn = new LogicalReplicationConnection(&quot;Host=localhost;Username=test;Password=test&quot;);
await conn.Open();

var slot = new TestDecodingReplicationSlot(&quot;blog_slot&quot;);

// The following will loop until the cancellation token is triggered, and will print message types coming from PostgreSQL:
var cancellationTokenSource = new CancellationTokenSource();
await foreach (var message in conn.StartReplication(slot, cancellationTokenSource.Token))
{
    Console.WriteLine($&quot;Message: {message.Data}&quot;);

    // Always call SetReplicationStatus() or assign LastAppliedLsn and LastFlushedLsn individually
    // so that Npgsql can inform the server which WAL files can be removed/recycled.
    conn.SetReplicationStatus(message.WalEnd);
}
</code></pre>
<p>Inserting a row will produce the following string messages:</p>
<pre><code class="lang-output">Message: BEGIN 230413
Message: table public.blogs: INSERT: id[integer]:2 name[text]:'blog1'
Message: COMMIT 230413
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>Npgsql internally recycles the message instances it hands out. It is an error to use a message received from <code>StartReplication</code> once the next message has been read.</p>
</div>
<h2 id="physical-replication">Physical replication</h2>
<p>Finally, PostgreSQL also supports physical replication, which streams raw block data rather than logical events on changes. While useful for synchronizing PostgreSQL replicas and supported by Npgsql, this mode is unlikely to be useful for a typical .NET program client.</p>
<h2 id="additional-resources">Additional resources</h2>
<ul>
<li>See <a href="https://event-driven.io/en/push_based_outbox_pattern_with_postgres_logical_replication/">here</a> for a great post on implementing the outbox pattern via PostgreSQL logical replication. The outbox pattern guarantees delivery of an event from the database to e.g. a queue.</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/npgsql/doc/blob/main/conceptual/Npgsql/replication.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © Copyright 2024 The Npgsql Development Team
        </div>
      </div>
    </footer>
  </body>
</html>
